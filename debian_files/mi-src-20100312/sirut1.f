C***********************************************************************
C
C     SUBROUTINE:  BESSEL **New**
C                  ......
C                  ......
C
C***********************************************************************
C
      SUBROUTINE BESSEL(RADIUS,DXX,INFLBE,D,ND,SZZ,SLON,STRA,BETA,SBETA)
C
      INTEGER INFLBE,ND
      REAL    RADIUS,DXX,D
      REAL    SZZ(ND),SLON(ND),STRA(ND),BETA,SBETA
C
C.old PARAMETER (NBESS=5,ND=200)
      PARAMETER (NBESS=5)
C
      DIMENSION ROOT(NBESS),COEFJO(NBESS+1)
      DIMENSION ROOSX(NBESS)
      DIMENSION B(2)
C.old COMMON/GRID/XP,YP,AN,FI,D,G0
C.old COMMON/BESS/SZZ(ND),SLON(ND),STRA(ND)
C.old COMMON/BETAS/BETA,SBETA
 
      DATA ROOT/3.8317,7.0156,10.1735,13.3237,16.4706/
      DATA COEFJO/0.15,0.30,0.28,0.14,0.08,0.05/
 
      DELTA=1.
 
      DO 505 J=1,ND
      SZZ(J)=0.
      SLON(J)=0.
      STRA(J)=0.
  505 CONTINUE
 
 
      IDELTA=DELTA+0.5
C     DDD=D*0.001
      RINFLB=INFLBE
      XNDMAX=(RINFLB*D)/DXX
      NDMAX=XNDMAX
      WRITE(6,9877)RADIUS,DXX,D,INFLBE
 9877 FORMAT(1X,'   BESSEL CALCS:',3F10.0,I4,' (RADIUS,DXX,D,INFLBE)')
      WRITE(6,9878)NDMAX,ND
 9878 FORMAT(1X,'   NDMAX=',I5,'  ND=',I5)
      IF(NDMAX.GT.ND)WRITE(6,*)' WARNING ERROR IN TABULATING BESSEL'
 
C   RADIUS IS SORT OF RADIUS OF INFLUENCE IN M,DXX IS DISTANCE BETWEEN
C   ELEMENTS IN THE CORRELATION TABLE GIVEN IN M
      DO 50 L=1,NBESS
      ROOSX(L)=ROOT(L)/RADIUS
  50  CONTINUE
 
C   FIND THE FACTOR BETA (SIGMA(U)=SIGMA(Z)*SQRT(BETA)*G/F
      BETA=0.
      DO 100 L=1,NBESS
      BETA=BETA+0.5*ROOSX(L)*ROOSX(L)*COEFJO(L+1)
 100  CONTINUE
      SBETA=SQRT(BETA)
      WRITE(6,9879)BETA,SBETA
 9879 FORMAT(1X,'   BETA =',E15.2,' SBETA=',E15.2)
 
 
      X=0.
 
      DO 200 J=2,ND
CCCCC DO 200 J=2,NDMAX
      SUM00=0.
      SUM11=0.
      SUM20=0.
      SUM11R=0.
      X=X+DXX
C     WRITE(66,6)J,X,RADIUS,DXX
   6  FORMAT(1X,I6,3F12.2)
      N=1
C   CALCULATE ZERO AND FIRST ORDER BESSEL FUNCTIONS
      IER=0
      SUM00=SUM00+COEFJO(1)
C     WRITE(6,1003)SUM00,SUM11,SUM20
 
      DO 300 L=1,NBESS
C  Y=X*KN / RADIUS
      Y=X*ROOSX(L)
      IER=0
      CALL BESJR(Y,N,B,IER)
C     WRITE(6,1008)J,Y,N,B(1),B(2),IER
      SUM00=SUM00+COEFJO(L+1)*B(1)
      SUM11=SUM11+COEFJO(L+1)*ROOSX(L)*B(2)
      SUM20=SUM20+COEFJO(L+1)*ROOSX(L)*ROOSX(L)*B(1)
C     SUM11R=SUM11/X
 
C     WRITE(6,1004)COEFJO(L+1),ROOSX(L),B(1),B(2)
C     WRITE(66,1003)SUM00
 1009 FORMAT(1X,' ZZ, LON , TRANS',4F10.2)
 1003 FORMAT('  ZZ :',F10.2)
 1004 FORMAT(1X,4F10.2)
 1005 FORMAT(1X,4F10.2,'  J0')
 
  300 CONTINUE
      SZZ(J)=SUM00
      SLON(J)=SUM11/BETA/X
      STRA(J)=(SUM20-SUM11/X)/BETA
C     WRITE(6,1009)SZZ(J),SLON(J),STRA(J)
  200 CONTINUE
 
      J=1
      SZZ(J)=1.
      SLON(J)=1.
      STRA(J)=1.
C     WRITE(6,1009)SZZ(J),SLON(J),STRA(J)
 
      DO 500 J=1,ND
C
C     WRITE(66,1009)SZZ(J),SLON(J),STRA(J)
 500  CONTINUE
 
 1002 FORMAT(1X,'J-TYPE',I5,F10.2,I5,2F10.2,I5)
 
C     CALL CORPLO(IDELTA,DXX)
 
      END
C Q8QST4   FROM PORTLIB                                  01/21/86
      SUBROUTINE Q8QST4(NAME,LBRARY,ENTRY,VRSION)
C
C DIMENSION OF           NAME(1),LBRARY(1),ENTRY(1),VRSION(1)
C ARGUMENTS
C
C LATEST REVISION        APRIL 1977
C
C PURPOSE                MONITORS LIBRARY USE BY WRITING A RECORD WITH
C                        INFORMATION ABOUT THE CIRCUMSTANCES OF A
C                        LIBRARY ROUTINE CALL TO THE SYSTEM ACCOUNTING
C                        TAPE FOR LATER PROCESSING.
C
C NOTE---                THIS VERSION OF Q8QST4 SIMPLY RETURNS TO THE
C                        CALLING ROUTINE.  LOCAL IMPLEMENTORS MAY WISH
C                        TO IMPLEMENT A VERSION OF THIS ROUTINE THAT
C                        MONITORS USE OF NSSL ROUTINES WITH LOCAL
C                        MECHANISMS.  OTHERWISE IT WILL SAVE A SMALL
C                        AMOUNT OF SPACE AND TIME IF CALLS TO Q8QST4 ARE
C                        DELETED FROM ALL NSSL ROUTINES.
C
C.AF  INTEGER NAME(1),LBRARY(1),ENTRY(1),VRSION(1)
      character*(*) NAME,LBRARY,ENTRY,VRSION
C
      RETURN
      END
CXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
C ULIBER   FROM PORTLIB                                  01/21/86
      SUBROUTINE ULIBER (IERR,MESSG,NMESSG)
C
C DIMENSION OF           MESSG(1+(NMESSG-1)/NCPWD), WHERE NCPWD IS THE
C ARGUMENTS              NUMBER OF CHARACTERS THAT CAN BE STORED IN ONE
C                        INTEGER WORD.
C
C LATEST REVISION        APRIL 1977.
C
C PURPOSE                PRINTS AN ERROR MESSAGE.
C
C USAGE                  CALL ULIBER (IERR,MESSG,NMESSG)
C
C ARGUMENTS
C
C ON INPUT               IERR
C                          ERROR NUMBER.  IF IERR .LT. 32, THE ERROR IS
C                          CONSIDERED TO BE NON-FATAL AND ULIBER RETURNS
C                          AFTER PRINTING THE ERROR MESSAGE.  IF IERR
C                          .GE. 32 THE ERROR IS CONSIDERED FATAL, AND
C                          ULIBER STOPS AFTER PRINTING THE MESSAGE.
C                        MESSG
C                          THE ERROR MESSAGE TO BE PRINTED.
C                        NMESSG
C                          THE LENGTH OF THE MESSAGE, IN CHARACTERS.
C
CAF   DIMENSION MESSG(1)
      character*(*) MESSG
      INTEGER ERUNIT,PRUNIT
C
C ERUNIT SHOULD BE SET TO THE LOCAL UNIT NUMBER FOR ERROR MESSAGES.
C
      DATA ERUNIT/0/,PRUNIT/6/
C
      IF (ERUNIT .EQ. 0) WRITE(PRUNIT,1000)
C
 1000 FORMAT(50H1ULIBER, A SUBROUTINE TO PRINT ERROR MESSAGES, HAS/
     1       50H BEEN CALLED, BUT NO LOCAL IMPLEMENTATION OF      /
     2       50H ULIBER HAS BEEN PROVIDED.  TO PROPERLY IMPLEMENT /
     3       50H THIS SUBROUTINE FOR THE LOCAL MACHINE AND        /
     4       50H ENVIRONMENT, PLEASE SEE THE COMMENTS IN ULIBER.  /)
C
C REPLACE THE IF STATEMENT AND FORMAT STATEMENT ABOVE WITH THE FOLLOWING
C CODE WHERE $NCPWD SHOULD BE REPLACED WITH THE NUMBER OF CHARACTERS
C THAT CAN BE STORED IN ONE INTEGER WORD, AND $N SHOULD BE REPLACED BY
C THE VALUE OF 1+(79/$NCPWD).
C
C     MM=1+(NMESSG-1)/$NCPWD
C     WRITE(ERUNIT,1000) IERR,(MESSG(I),I=1,MM)
C1000 FORMAT(18H ****ERROR NUMBER ,I5,25H,ERROR MESSAGE FOLLOWS.../
C    1       ($N A $NCPWD ))
C
   10 IF (IERR .GE. 32) STOP
      RETURN
      END
CXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
C BESR     FROM LOCLIB                                   01/21/86
C PACKAGE BESR           (NOTE---DOCUMENTATION FOR INDIVIDUAL ROUTINES
C                        FOLLOWS THE GENERAL PACKAGE INFORMATION.)
C
C LATEST REVISION        JANUARY 1985
C
C PURPOSE                TO CALCULATE BESSEL FUNCTIONS I AND J FOR REAL
C                        ARGUMENT AND INTEGER ORDERS.
C
C USAGE                  TO CALCULATE I BESSEL FUNCTIONS---
C
C                          CALL BESIR(X,N,B,IER)
C
C                        TO CALCULATE J BESSEL FUNCTIONS---
C
C                          CALL BESJR(X,N,B,IER)
C
C SPECIAL CONDITIONS     NONE
C
C I/O                    NONE, EXCEPT FOR ERROR MESSAGES PRODUCED BY
C                        CALLING THE ERROR HANDLING ROUTINE ULIBER.
C
C PRECISION              SINGLE
C
C REQUIRED LIBRARY       ULIBER AND Q8QST4, WHICH ARE LOADED BY DEFAULT
C FILES                  ON NCAR'S CRAY MACHINES.
C
C LANGUAGE               FORTRAN
C
C HISTORY                DAVID J. SOOKNE WROTE THE CORE ROUTINE B2SLRI,
C                        WHICH WAS ORIGINALLY DOUBLE PRECISION.  THE
C                        SINGLE PRECISION VERSION, AND THE USER ENTRIES
C                        BESIR AND BESJR WERE WRITTEN BY RUSSELL K. REW
C                        IN SEPTEMBER, 1977.
C
C
C PORTABILITY            THIS PACKAGE CONFORMS TO THE 1966 ANSI STANDARD
C                        AS CONFIRMED BY THE PFORT VERIFIER.  THERE ARE
C                        FOUR MACHINE DEPENDENT CONSTANTS IN B2SLRI THAT
C                        ARE DESCRIBED IN COMMENT CARDS.
C
C
C REFERENCES             'BESSEL FUNCTIONS OF REAL ARGUMENT AND INTEGER
C                        ORDER' AND 'CERTIFICATION OF AN ALGORITHM FOR
C                        BESSEL FUNCTIONS OF REAL ARGUMENT', BY DAVID J.
C                        SOOKNE, JOURNAL OF RESEARCH OF THE NATIONAL
C                        BUREAU OF STANDARDS-B. MATHEMATICAL SCIENCES,
C                        VOL. 77A, NOS. 3 AND 4, JULY-DECEMBER 1973.
C
C METHOD                 BACKWARD RECURSION WITH STRICT CONTROL OF
C                        ERROR.
C***********************************************************************
CXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
C
C SUBROUTINE BESIR (X,N,B,IER)
C
C DIMENSION OF           B(N+1)
C ARGUMENTS
C
C PURPOSE                TO CALCULATE I BESSEL FUNCTIONS FOR REAL
C                        ARGUMENT AND INTEGER ORDER
C
C USAGE                  CALL BESIR (X,N,B,IER)
C
C ARGUMENTS
C
C ON INPUT               X
C                          REAL ARGUMENT FOR WHICH I BESSEL FUNCTIONS
C                          ARE TO BE CALCULATED.  ABS(X) MUST BE LESS
C                          THAN THE LARGEST REAL ARGUMENT THAT THE
C                          FORTRAN FUNCTION EXP CAN HANDLE.
C
C                        N
C                          INTEGER, THE HIGHEST ORDER TO BE CALCULATED.
C                          N MUST BE GREATER THAN OR EQUAL TO ZERO.
C
C ON OUTPUT              B
C                          REAL VECTOR OF LENGTH N+1 CONTAINING THE
C                          BESSEL FUNCTION VALUES I-SUB-0(X),I-SUB-1(X),
C                          ...,I-SUB-N(X) IN B(1),B(2),...,B(N+1).
C                        IER
C                          AN INTEGER ERROR FLAG.
C                          =0 IF ALL DESIRED ORDERS HAVE BEEN CALCULATED
C                             SATISFACTORILY,
C                          =1 IF ABS(X) IS TOO LARGE FOR INPUT TO EXP,
C                          =2 IF N IS LESS THAN ZERO,
C                          =2+K IF ONLY THE FIRST K RESULTS ARE CORRECT.
C                             IN THE RETURNED VALUES B(M) FOR M GREATER
C                             THAN K, APPROXIMATELY THE LAST
C                             ALOG10(ABS(B(M)/B(K))) SIGNIFICANT DIGITS
C                             ARE IN ERROR.
C
C ACCURACY               IN TESTS RUN ON A CDC 7600 WITH ORDERS FROM
C                        0 THROUGH 10 AND WITH 2500 RANDOM VALUES OF THE
C                        ARGUMENT BETWEEN 0 AND 50, THE MAXIMUM RELATIVE
C                        ERROR OBSERVED WAS ABOUT 9.0E-14.
C***********************************************************************
CXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
C
C SUBROUTINE BESJR (X,N,B,IER)
C
C DIMENSION OF           B(N+1)
C ARGUMENTS
C
C PURPOSE                TO CALCULATE J BESSEL FUNCTIONS FOR REAL
C                        ARGUMENT AND INTEGER ORDER
C
C USAGE                  CALL BESJR (X,N,B,IER)
C
C ARGUMENTS
C
C ON INPUT               X
C                          REAL ARGUMENT FOR WHICH J BESSEL FUNCTIONS
C                        ARE TO BE CALCULATED.
C
C                        N
C                          INTEGER, THE HIGHEST ORDER TO BE CALCULATED.
C                          N MUST BE GREATER THAN OR EQUAL TO ZERO.
C
C ON OUTPUT              B
C                          REAL VECTOR OF LENGTH N+1 CONTAINING THE
C                          BESSEL FUNCTION VALUES J-SUB-0(X),J-SUB-1(X),
C                          ...,J-SUB-N(X) IN B(1),B(2),...,B(N+1).
C                        IER
C                          AN INTEGER ERROR FLAG.
C                          =0 IF ALL DESIRED ORDERS HAVE BEEN CALCULATED
C                             SATISFACTORILY,
C                          =1 IF ABS(X) IS TOO LARGE  ,
C                          =2 IF N IS LESS THAN ZERO,
C                          =2+K IF ONLY THE FIRST K RESULTS ARE CORRECT.
C                             IN THE RETURNED VALUES B(M) FOR M GREATER
C                             THAN K, APPROXIMATELY THE LAST
C                             ALOG10(ABS(B(M)/B(K))) SIGNIFICANT DIGITS
C                             ARE IN ERROR.
C
C ACCURACY               IN TESTS RUN ON A CDC 7600 WITH ORDERS FROM
C                        0 THROUGH 10 AND WITH 2500 RANDOM VALUES OF THE
C                        ARGUMENT BETWEEN 0 AND 50, THE MAXIMUM RELATIVE
C                        ERROR (OR ABSOLUTE ERROR WHEN IT WAS LARGER,
C                        NEAR ZEROS OF THE J BESSEL FUNCTION) OBSERVED
C                        WAS 3.5E-14.
C***********************************************************************
CXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      SUBROUTINE BESIR (X,N,B,IER)
      DIMENSION       B(1)
      LOGICAL Q8Q4
      SAVE Q8Q4
      DATA Q8Q4 /.TRUE./
      DATA IORJ/1/,XLARGE/741.66/
C
C THE FOLLOWING CALL IS FOR GATHERING STATISTICS ON LIBRARY USE AT NCAR
C
      IF (Q8Q4) THEN
          CALL Q8QST4('LOCLIB','BESR','BESIR','VERSION 01')
          Q8Q4 = .FALSE.
      ENDIF
      NB = N+1
      CALL B2SLRI (X,N+1,IORJ,B,NCALC)
      IER = 0
      IF (NCALC .EQ. NB) GO TO 103
      IF (NCALC .GE. 0) GO TO 102
      IF (N .GE. 0) GO TO 101
      IER = 2
      CALL ULIBER (IER,' IN BESIR, N OUT OF RANGE',25)
      GO TO 103
  101 IER = 1
      CALL ULIBER (IER,' IN BESIR, X OUT OF RANGE',25)
      GO TO 103
  102 IER = 2+NCALC
      CALL ULIBER (IER,' IN BESIR, ACCURACY LOST FOR SOME ORDERS',40)
  103 RETURN
      END
CXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      SUBROUTINE BESJR (X,N,B,IER)
C
C
      DIMENSION       B(1)
      LOGICAL Q8Q4
      SAVE Q8Q4
      DATA Q8Q4 /.TRUE./
      DATA IORJ/0/,XLARGE/1000000./
C
C THE FOLLOWING CALL IS FOR GATHERING STATISTICS ON LIBRARY USE AT NCAR
C
      IF (Q8Q4) THEN
          CALL Q8QST4('LOCLIB','BESR','BESJR','VERSION 01')
          Q8Q4 = .FALSE.
      ENDIF
      NB = N+1
      CALL B2SLRI (X,N+1,IORJ,B,NCALC)
      IER = 0
      IF (NCALC .EQ. NB) GO TO 103
      IF (NCALC .GE. 0) GO TO 102
      IF (N .GE. 0) GO TO 101
      IER = 2
      CALL ULIBER (IER,' IN BESJR, N OUT OF RANGE',25)
      GO TO 103
  101 IER = 1
      CALL ULIBER (IER,' IN BESJR, X OUT OF RANGE',25)
      GO TO 103
  102 IER = 2+NCALC
      CALL ULIBER (IER,' IN BESJR, ACCURACY LOST FOR SOME ORDERS',40)
  103 RETURN
      END
CXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      SUBROUTINE B2SLRI (X,NB,IZE,B,NCALC)
C
C THIS ROUTINE CALCULATES BESSEL FUNCTIONS I AND J OF REAL
C ARGUMENT AND INTEGER ORDER.
C
C
C      EXPLANATION OF VARIABLES IN THE CALLING SEQUENCE
C
C X     REAL (SINGLE PRECISION) ARGUMENT FOR WHICH I*S OR J*S
C       ARE TO BE CALCULATED.  IF I*S ARE TO BE CALCULATED,
C       ABS(X) MUST BE LESS THAN EXPARG (WHICH SEE BELOW).
C NB    INTEGER TYPE.  1 + HIGHEST ORDER TO BE CALCULATED.
C       IT MUST BE POSITIVE.
C IZE   INTEGER TYPE.  ZERO IF J*S ARE TO BE CALCULATED, 1
C       IF I*S ARE TO BE CALCULATED.
C B     REAL VECTOR OF LENGTH NB, NEED NOT BE
C       INITIALIZED BY USER.  IF THE ROUTINE TERMINATES
C       NORMALLY (NCALC=NB), IT RETURNS J(OR I)-SUB-ZERO
C       THROUGH J(OR I)-SUB-NB-MINUS-ONE OF X IN THIS
C       VECTOR.
C NCALC INTEGER TYPE, NEED NOT BE INITIALIZED BY USER.
C       BEFORE USING THE RESULTS, THE USER SHOULD CHECK THAT
C       NCALC=NB, I.E. ALL ORDERS HAVE BEEN CALCULATED TO
C       THE DESIRED ACCURACY.  SEE ERROR RETURNS BELOW.
C
C
C     EXPLANATION OF MACHINE-DEPENDENT CONSTANTS
C
C NSIG  DECIMAL SIGNIFICANCE DESIRED.  SHOULD BE SET TO
C       IFIX(ALOG10(2)*NBIT+1), WHERE NBIT IS THE NUMBER OF
C       BITS IN THE MANTISSA OF A REAL VARIABLE.
C       SETTING NSIG LOWER WILL RESULT IN DECREASED ACCURACY
C       WHILE SETTING NSIG HIGHER WILL INCREASE CPU TIME
C       WITHOUT INCREASING ACCURACY.  THE TRUNCATION ERROR
C       IS LIMITED TO T=.5*10**-NSIG FOR J*S OF ORDER LESS
C       THAN ARGUMENT, AND TO A RELATIVE ERROR OF T FOR
C       I*S AND THE OTHER J*S.
C NTEN  LARGEST INTEGER K SUCH THAT 10**K IS MACHINE-
C       REPRESENTABLE IN REAL.
C LARGEX UPPER LIMIT ON THE MAGNITUDE OF X.  BEAR IN MIND
C       THAT IF ABS(X)=N, THEN AT LEAST N ITERATIONS OF THE
C       BACKWARD RECURSION WILL BE EXECUTED.
C EXPARG LARGEST REAL ARGUMENT THAT THE LIBRARY
C       EXP ROUTINE CAN HANDLE.
C
C
C                  ERROR RETURNS
C
C       LET G DENOTE EITHER I OR J.
C       IN CASE OF AN ERROR, NCALC.NE.NB, AND NOT ALL G*S
C  ARE CALCULATED TO THE DESIRED ACCURACY.
C       IF NCALC.LT.0, AN ARGUMENT IS OUT OF RANGE.  NB.LE.0
C  OR IZE IS NEITHER 0 NOR 1 OR IZE=1 AND ABS(X).GE.EXPARG.
C  IN THIS CASE, THE B-VECTOR IS NOT CALCULATED, AND NCALC
C  IS SET TO MIN0(NB,0)-1 SO NCALC.NE.NB.
C       NB.GT.NCALC.GT.0 WILL OCCUR IF NB.GT.MAGX AND ABS(G-
C  SUB-NB-OF-X/G-SUB-MAGX+NP-OF-X).LT.10.**(NTEN/2), I.E. NB
C  IS MUCH GREATER THAN MAGX.  IN THIS CASE, B(N) IS CALCU-
C  LATED TO THE DESIRED ACCURACY FOR N.LE.NCALC, BUT FOR
C  NCALC.LT.N.LE.NB, PRECISION IS LOST.  IF N.GT.NCALC AND
C  ABS(B(NCALC)/B(N)).EQ.10**-K, THEN THE LAST K SIGNIFICANT
C  FIGURES OF B(N) ARE ERRONEOUS.  IF THE USER WISHES TO
C  CALCULATE B(N) TO HIGHER ACCURACY, HE SHOULD USE AN
C  ASYMPTOTIC FORMULA FOR LARGE ORDER.
C
      REAL            X          ,B          ,P          ,TEST       ,
     1                TEMPA      ,TEMPB      ,TEMPC      ,EXPARG     ,
     2                SIGN       ,SUM        ,TOVER      ,PLAST      ,
     3                POLD       ,PSAVE      ,PSAVEL
      DIMENSION       B(NB)
      DATA NSIG,NTEN,LARGEX,EXPARG
     1   /15,293,1000000,741.66E0/
C
      TEMPA = ABS(X)
      MAGX = IFIX((TEMPA))
      IF (NB.GT.0 .AND. MAGX.LE.LARGEX .AND.
     1    (IZE.EQ.0 .OR. (IZE.EQ.1 .AND. TEMPA.LE.EXPARG))) GO TO 101
C
C ERROR RETURN -- X,NB,OR IZE IS OUT OF RANGE
C
      NCALC = MIN0(NB,0)-1
      RETURN
  101 SIGN = (real(1-2*IZE))
      NCALC = NB
C
C USE 2-TERM ASCENDING SERIES FOR SMALL X
C
      IF (TEMPA**4 .LT. .1E0**NSIG) GO TO 123
C
C INITIALIZE THE CALCULATION OF P*S
C
      NBMX = NB-MAGX
      N = MAGX+1
      PLAST = 1.E0
      P = (real(2*N))/TEMPA
C
C CALCULATE GENERAL SIGNIFICANCE TEST
C
      TEST = 2.E0*1.E1**NSIG
      IF (IZE.EQ.1 .AND. 2*MAGX.GT.5*NSIG) TEST = SQRT(TEST*P)
      IF (IZE.EQ.1 .AND. 2*MAGX.LE.5*NSIG) TEST = TEST/1.585**MAGX
      M = 0
      IF (NBMX .LT. 3) GO TO 103
C
C CALCULATE P*S UNTIL N=NB-1.  CHECK FOR POSSIBLE OVERFLOW.
C
C THE FOLLOWING DEVIOUS COMPUTATION REPLACES
C     TOVER=10.0**(NTEN-NSIG)
C AND IS NECESSITATED BY THE POOR POWER ALGORITHM ON THE NCAR 7600
C IN ORDER TO PREVENT OVERFLOW
C
      INTEMP = NTEN-NSIG
      INHLF = INTEMP/2
      TOVER = 10.0**INHLF*10.0**(INTEMP-INHLF)
      NSTART = MAGX+2
      NEND = NB-1
      DO 102 N=NSTART,NEND
         POLD = PLAST
         PLAST = P
         P = (real(2*N))*PLAST/TEMPA-SIGN*POLD
c.old    IF (P-TOVER) 102,102,104
         IF (P.gt.TOVER) goto 104
  102 CONTINUE
C
C CALCULATE SPECIAL SIGNIFICANCE TEST FOR NBMX.GT.2.
C
      TEST = AMAX1(TEST,SQRT(PLAST*1.E1**NSIG)*SQRT(2.E0*P))
C
C CALCULATE P*S UNTIL SIGNIFICANCE TEST PASSES
C
  103 N = N+1
      POLD = PLAST
      PLAST = P
      P = (real(2*N))*PLAST/TEMPA-SIGN*POLD
      IF (P .LT. TEST) GO TO 103
      IF (IZE.EQ.1 .OR. M.EQ.1) GO TO 109
C
C FOR J*S, A STRONG VARIANT OF THE TEST IS NECESSARY.
C CALCULATE IT, AND CALCULATE P*S UNTIL THIS TEST IS PASSED.
C
      M = 1
      TEMPB = P/PLAST
      TEMPC = (real(N+1))/TEMPA
      IF (TEMPB+1.E0/TEMPB .GT. 2.E0*TEMPC)
     1    TEMPB = TEMPC+SQRT(TEMPC**2-1.E0)
      TEST = TEST/SQRT(TEMPB-1.E0/TEMPB)
c.old IF (P-TEST) 103,109,109
      IF (P.ge.TEST) goto 109
C
C TO AVOID OVERFLOW, DIVIDE P*S BY TOVER.  CALCULATE P*S
C UNTIL ABS(P).GT.1.
C
C HERE IS THAT DEVIOUS COMPUTATION AGAIN, THIS TIME TO REPLACE
C 104 TOVER=10.0**NTEN
C
  104 INHLF = NTEN/2
      TOVER = 10.0**INHLF*10.0**(NTEN-INHLF)
      P = P/TOVER
      PLAST = PLAST/TOVER
      PSAVE = P
      PSAVEL = PLAST
      NSTART = N+1
  105 N = N+1
      POLD = PLAST
      PLAST = P
      P = (real(2*N))*PLAST/TEMPA-SIGN*POLD
      IF (P .LE. 1.E0) GO TO 105
      TEMPB = (real(2*N))/TEMPA
      IF (IZE .EQ. 1) GO TO 106
      TEMPC = .5E0*TEMPB
      TEMPB = PLAST/POLD
      IF (TEMPB+1.E0/TEMPB .GT. 2.E0*TEMPC)
     1    TEMPB = TEMPC+SQRT(TEMPC**2-1.E0)
C
C CALCULATE BACKWARD TEST, AND FIND NCALC, THE HIGHEST N
C SUCH THAT THE TEST IS PASSED.
C
  106 TEST = .5E0*POLD*PLAST*(1.E0-1.E0/TEMPB**2)/1.E1**NSIG
      P = PLAST*TOVER
      N = N-1
      NEND = MIN0(NB,N)
      DO 107 NCALC=NSTART,NEND
         POLD = PSAVEL
         PSAVEL = PSAVE
         PSAVE = (real(2*N))*PSAVEL/TEMPA-SIGN*POLD
c.old    IF (PSAVE*PSAVEL-TEST) 107,107,108
         IF (PSAVE*PSAVEL.gt.TEST) goto 108
  107 CONTINUE
      NCALC = NEND+1
  108 NCALC = NCALC-1
C
C THE SUM B(1)+2B(3)+2B(5)... IS USED TO NORMALIZE.  M, THE
C COEFFICIENT OF B(N), IS INITIALIZED TO 2 OR 0.
C
  109 N = N+1
      M = 2*N-4*(N/2)
C
C INITIALIZE THE BACKWARD RECURSION AND THE NORMALIZATION
C SUM
C
      TEMPB = 0.E0
      TEMPA = 1.E0/P
      SUM = (real(M))*TEMPA
      NEND = N-NB
c
c.old IF (NEND) 114,112,110
      if (NEND.gt.0) then
C
C RECUR BACKWARD VIA DIFFERENCE EQUATION, CALCULATING (BUT
C NOT STORING) B(N), UNTIL N=NB.
C
c.110 DO 111 L=1,NEND
      DO 111 L=1,NEND
         N = N-1
         TEMPC = TEMPB
         TEMPB = TEMPA
         TEMPA = ((real(2*N))*TEMPB)/X-SIGN*TEMPC
         M = 2-M
         SUM = SUM+(real(M))*TEMPA
  111 CONTINUE
c
      end if
c
      if (NEND.ge.0) then
C
C STORE B(NB)
C
c.112 B(N) = TEMPA
      B(N) = TEMPA
      IF (NB .GT. 1) GO TO 113
C
C NB=1.  SINCE 2*TEMPA WAS ADDED TO THE SUM, TEMPA MUST BE
C SUBTRACTED
C
      SUM = SUM-TEMPA
      GO TO 120
C
C CALCULATE AND STORE B(NB-1)
C
  113 N = N-1
      B(N) = ((real(2*N))*TEMPA)/X-SIGN*TEMPB
      IF (N .EQ. 1) GO TO 119
      M = 2-M
      SUM = SUM+(real(M))*B(N)
      GO TO 116
c
      else
C
C N.LT.NB, SO STORE B(N) AND SET HIGHER ORDERS TO ZERO
C
c.114 B(N) = TEMPA
      B(N) = TEMPA
      NEND = -NEND
      DO 115 L=1,NEND
         B(N+L) = 0.E0
  115 CONTINUE
c
      end if
c
  116 NEND = N-2
      IF (NEND .EQ. 0) GO TO 118
C
C CALCULATE VIA DIFFERENCE EQUATION AND STORE B(N),
C UNTIL N=2
C
      DO 117 L=1,NEND
         N = N-1
         B(N) = ((real(2*N))*B(N+1))/X-SIGN*B(N+2)
         M = 2-M
         SUM = SUM+(real(M))*B(N)
  117 CONTINUE
C
C CALCULATE B(1)
C
  118 B(1) = 2.E0*B(2)/X-SIGN*B(3)
  119 SUM = SUM+B(1)
C
C NORMALIZE--IF IZE=1, DIVIDE SUM BY COSH(X).  DIVIDE ALL
C B(N) BY SUM.
C
  120 IF (IZE .EQ. 0) GO TO 121
      TEMPA = EXP(ABS(X))
      SUM = 2.E0*SUM/(TEMPA+1.E0/TEMPA)
  121 DO 122 N=1,NB
         B(N) = B(N)/SUM
  122 CONTINUE
      RETURN
C
C TWO-TERM ASCENDING SERIES FOR SMALL X
C
  123 TEMPA = 1.E0
      TEMPB = -.25E0*X*X*SIGN
      B(1) = 1.E0+TEMPB
      IF (NB .EQ. 1) GO TO 125
      DO 124 N=2,NB
         TEMPA = TEMPA*X/(real(2*N-2))
         B(N) = TEMPA*(1.E0+TEMPB/(real(N)))
  124 CONTINUE
  125 RETURN
C
C REVISION HISTORY---
C
C OCTOBER 1978     FIRST ADDED TO NSSL.
C NOVEMBER 1978    CHANGED THE VALUE OF THE MACHINE DEPENDENT CONSTANT
C                  NTEN FROM 322 TO 293 TO CORRECT AN UNDETECTED
C                  UNDERFLOW AND SUBSEQUENT DIVISION OF 0 BY 0 WHEN
C                  BESIR WAS CALLED WITH LARGE N (GREATER THAN 140).
C-----------------------------------------------------------------------
      END
